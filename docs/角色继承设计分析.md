# 角色继承设计分析

## 📋 需求分析

您提出的**角色继承和层级角色**是一个非常重要的业务需求。在实际业务场景中，确实存在以下情况：

### 常见角色继承场景

1. **组织架构继承**
   - 总经理 → 部门经理 → 主管 → 普通员工
   - 高级管理员 → 管理员 → 操作员

2. **权限继承**
   - 上级角色自动拥有下级角色的所有权限
   - 下级角色不能拥有超过上级角色的权限

3. **数据权限继承**
   - 上级可以查看下级的数据
   - 下级只能查看自己权限范围内的数据

---

## 🏗️ 角色继承设计方案

### 方案1: 自关联角色表（推荐）

#### 核心思路
- 在角色表中增加 `parent_role_id` 字段
- 通过递归查询实现权限继承
- 支持多层级角色继承

#### 优化后的角色表结构

```sql
-- ==============================================
-- 系统角色表（支持继承）
-- ==============================================

CREATE TABLE sys_role (
    role_id VARCHAR(32) PRIMARY KEY COMMENT '角色ID',
    tenant_id VARCHAR(32) NOT NULL COMMENT '租户ID',
    parent_role_id VARCHAR(32) COMMENT '父角色ID',
    role_code VARCHAR(64) NOT NULL COMMENT '角色代码',
    role_name VARCHAR(128) NOT NULL COMMENT '角色名称',
    role_type ENUM('SYSTEM', 'TENANT', 'CUSTOM') DEFAULT 'TENANT' COMMENT '角色类型',
    role_level INT DEFAULT 0 COMMENT '角色层级',
    description TEXT COMMENT '角色描述',
    data_scope ENUM('ALL', 'CUSTOM', 'DEPT', 'DEPT_AND_CHILD', 'SELF') DEFAULT 'SELF' COMMENT '数据权限范围',
    inherit_permissions BOOLEAN DEFAULT TRUE COMMENT '是否继承父角色权限',
    inherit_data_scope BOOLEAN DEFAULT FALSE COMMENT '是否继承父角色数据权限',
    status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE' COMMENT '状态',
    sort_order INT DEFAULT 0 COMMENT '排序',
    created_by VARCHAR(64) NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by VARCHAR(64),
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_tenant (tenant_id),
    INDEX idx_parent_role (parent_role_id),
    INDEX idx_role_code (role_code),
    INDEX idx_role_name (role_name),
    INDEX idx_role_level (role_level),
    INDEX idx_status (status),
    FOREIGN KEY (tenant_id) REFERENCES tenant(tenant_id),
    FOREIGN KEY (parent_role_id) REFERENCES sys_role(role_id)
) COMMENT '系统角色表';
```

### 方案2: 角色继承关联表

#### 核心思路
- 创建独立的角色继承关联表
- 支持更复杂的继承关系
- 可以配置继承的具体权限类型

#### 角色继承关联表

```sql
-- ==============================================
-- 角色继承关联表
-- ==============================================

CREATE TABLE sys_role_inheritance (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    child_role_id VARCHAR(32) NOT NULL COMMENT '子角色ID',
    parent_role_id VARCHAR(32) NOT NULL COMMENT '父角色ID',
    inherit_type ENUM('ALL', 'PERMISSIONS_ONLY', 'DATA_SCOPE_ONLY', 'CUSTOM') DEFAULT 'ALL' COMMENT '继承类型',
    inherit_permissions BOOLEAN DEFAULT TRUE COMMENT '是否继承权限',
    inherit_data_scope BOOLEAN DEFAULT FALSE COMMENT '是否继承数据权限',
    custom_permissions JSON COMMENT '自定义权限配置',
    status ENUM('ACTIVE', 'INACTIVE') DEFAULT 'ACTIVE' COMMENT '状态',
    created_by VARCHAR(64) NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by VARCHAR(64),
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_child_role (child_role_id),
    INDEX idx_parent_role (parent_role_id),
    INDEX idx_status (status),
    UNIQUE KEY uk_role_inheritance (child_role_id, parent_role_id),
    FOREIGN KEY (child_role_id) REFERENCES sys_role(role_id),
    FOREIGN KEY (parent_role_id) REFERENCES sys_role(role_id)
) COMMENT '角色继承关联表';
```

---

## 🔄 权限继承查询逻辑

### 1. 递归查询用户的所有角色（包括继承）

```sql
-- 递归查询用户的所有角色（包括继承的角色）
WITH RECURSIVE user_all_roles AS (
    -- 直接分配的角色
    SELECT 
        r.role_id,
        r.role_code,
        r.role_name,
        r.role_level,
        r.parent_role_id,
        r.inherit_permissions,
        r.inherit_data_scope,
        0 as inheritance_level
    FROM sys_user_role ur
    JOIN sys_role r ON ur.role_id = r.role_id
    WHERE ur.user_id = ? AND r.status = 'ACTIVE'
    
    UNION ALL
    
    -- 继承的父角色
    SELECT 
        pr.role_id,
        pr.role_code,
        pr.role_name,
        pr.role_level,
        pr.parent_role_id,
        pr.inherit_permissions,
        pr.inherit_data_scope,
        uar.inheritance_level + 1
    FROM sys_role pr
    JOIN user_all_roles uar ON pr.role_id = uar.parent_role_id
    WHERE pr.status = 'ACTIVE' AND uar.inherit_permissions = TRUE
)
SELECT DISTINCT * FROM user_all_roles
ORDER BY role_level DESC, inheritance_level;
```

### 2. 获取用户的所有权限（包括继承）

```sql
-- 获取用户的所有权限（包括继承的权限）
WITH RECURSIVE user_all_roles AS (
    -- 直接分配的角色
    SELECT r.role_id, r.inherit_permissions
    FROM sys_user_role ur
    JOIN sys_role r ON ur.role_id = r.role_id
    WHERE ur.user_id = ? AND r.status = 'ACTIVE'
    
    UNION ALL
    
    -- 继承的父角色
    SELECT pr.role_id, pr.inherit_permissions
    FROM sys_role pr
    JOIN user_all_roles uar ON pr.role_id = uar.parent_role_id
    WHERE pr.status = 'ACTIVE' AND uar.inherit_permissions = TRUE
)
SELECT DISTINCT 
    p.permission_id,
    p.permission_code,
    p.permission_name,
    p.permission_type,
    p.resource_type,
    p.resource_id,
    p.action
FROM user_all_roles uar
JOIN sys_role_permission rp ON uar.role_id = rp.role_id
JOIN sys_permission p ON rp.permission_id = p.permission_id
WHERE p.status = 'ACTIVE';
```

### 3. 获取用户的数据权限范围（包括继承）

```sql
-- 获取用户的最大数据权限范围（继承上级角色）
WITH RECURSIVE user_all_roles AS (
    -- 直接分配的角色
    SELECT 
        r.role_id, 
        r.data_scope,
        r.inherit_data_scope,
        r.role_level
    FROM sys_user_role ur
    JOIN sys_role r ON ur.role_id = r.role_id
    WHERE ur.user_id = ? AND r.status = 'ACTIVE'
    
    UNION ALL
    
    -- 继承的父角色
    SELECT 
        pr.role_id,
        pr.data_scope,
        pr.inherit_data_scope,
        pr.role_level
    FROM sys_role pr
    JOIN user_all_roles uar ON pr.role_id = uar.parent_role_id
    WHERE pr.status = 'ACTIVE' AND uar.inherit_data_scope = TRUE
)
SELECT 
    CASE 
        WHEN MAX(CASE data_scope WHEN 'ALL' THEN 4 WHEN 'CUSTOM' THEN 3 WHEN 'DEPT_AND_CHILD' THEN 2 WHEN 'DEPT' THEN 1 ELSE 0 END) >= 4 THEN 'ALL'
        WHEN MAX(CASE data_scope WHEN 'ALL' THEN 4 WHEN 'CUSTOM' THEN 3 WHEN 'DEPT_AND_CHILD' THEN 2 WHEN 'DEPT' THEN 1 ELSE 0 END) >= 3 THEN 'CUSTOM'
        WHEN MAX(CASE data_scope WHEN 'ALL' THEN 4 WHEN 'CUSTOM' THEN 3 WHEN 'DEPT_AND_CHILD' THEN 2 WHEN 'DEPT' THEN 1 ELSE 0 END) >= 2 THEN 'DEPT_AND_CHILD'
        WHEN MAX(CASE data_scope WHEN 'ALL' THEN 4 WHEN 'CUSTOM' THEN 3 WHEN 'DEPT_AND_CHILD' THEN 2 WHEN 'DEPT' THEN 1 ELSE 0 END) >= 1 THEN 'DEPT'
        ELSE 'SELF'
    END as max_data_scope
FROM user_all_roles;
```

---

## 📊 角色继承数据示例

### 1. 创建层级角色结构

```sql
-- 插入角色数据（建立继承关系）
INSERT INTO sys_role (role_id, tenant_id, parent_role_id, role_code, role_name, role_type, role_level, data_scope, inherit_permissions, inherit_data_scope, created_by) VALUES
-- 系统级角色
('ROLE_SYS_ADMIN', 'TENANT_001', NULL, 'SYSTEM_ADMIN', '系统管理员', 'SYSTEM', 1, 'ALL', FALSE, FALSE, 'SYSTEM'),

-- 租户级角色
('ROLE_TENANT_ADMIN', 'TENANT_001', 'ROLE_SYS_ADMIN', 'TENANT_ADMIN', '租户管理员', 'TENANT', 2, 'ALL', TRUE, FALSE, 'SYSTEM'),
('ROLE_DEPT_MANAGER', 'TENANT_001', 'ROLE_TENANT_ADMIN', 'DEPT_MANAGER', '部门经理', 'TENANT', 3, 'DEPT_AND_CHILD', TRUE, TRUE, 'SYSTEM'),
('ROLE_TEAM_LEADER', 'TENANT_001', 'ROLE_DEPT_MANAGER', 'TEAM_LEADER', '团队负责人', 'TENANT', 4, 'DEPT', TRUE, TRUE, 'SYSTEM'),
('ROLE_EMPLOYEE', 'TENANT_001', 'ROLE_TEAM_LEADER', 'EMPLOYEE', '普通员工', 'TENANT', 5, 'SELF', TRUE, TRUE, 'SYSTEM'),

-- 功能角色
('ROLE_HR_ADMIN', 'TENANT_001', 'ROLE_TENANT_ADMIN', 'HR_ADMIN', 'HR管理员', 'CUSTOM', 2, 'DEPT_AND_CHILD', TRUE, FALSE, 'SYSTEM'),
('ROLE_HR_SPECIALIST', 'TENANT_001', 'ROLE_HR_ADMIN', 'HR_SPECIALIST', 'HR专员', 'CUSTOM', 3, 'DEPT', TRUE, TRUE, 'SYSTEM');
```

### 2. 角色层级结构图

```
系统管理员 (SYSTEM_ADMIN)
├── 租户管理员 (TENANT_ADMIN)
│   ├── 部门经理 (DEPT_MANAGER)
│   │   └── 团队负责人 (TEAM_LEADER)
│   │       └── 普通员工 (EMPLOYEE)
│   └── HR管理员 (HR_ADMIN)
│       └── HR专员 (HR_SPECIALIST)
```

### 3. 权限继承示例

```sql
-- 为系统管理员分配基础权限
INSERT INTO sys_role_permission (role_id, permission_id, created_by) VALUES
('ROLE_SYS_ADMIN', 'PERM_SYSTEM_MANAGE', 'SYSTEM'),
('ROLE_SYS_ADMIN', 'PERM_USER_MANAGE', 'SYSTEM'),
('ROLE_SYS_ADMIN', 'PERM_ROLE_MANAGE', 'SYSTEM');

-- 租户管理员继承系统管理员权限，并增加租户特定权限
INSERT INTO sys_role_permission (role_id, permission_id, created_by) VALUES
('ROLE_TENANT_ADMIN', 'PERM_TENANT_MANAGE', 'SYSTEM'),
('ROLE_TENANT_ADMIN', 'PERM_DEPT_MANAGE', 'SYSTEM');

-- 部门经理继承租户管理员权限，并增加部门管理权限
INSERT INTO sys_role_permission (role_id, permission_id, created_by) VALUES
('ROLE_DEPT_MANAGER', 'PERM_DEPT_VIEW', 'SYSTEM'),
('ROLE_DEPT_MANAGER', 'PERM_EMPLOYEE_MANAGE', 'SYSTEM');
```

---

## 🔧 角色继承管理功能

### 1. 检查角色继承循环

```sql
-- 检查角色继承是否存在循环引用
CREATE PROCEDURE CheckRoleInheritanceCycle(IN p_role_id VARCHAR(32))
BEGIN
    DECLARE cycle_found BOOLEAN DEFAULT FALSE;
    
    WITH RECURSIVE role_hierarchy AS (
        SELECT role_id, parent_role_id, 1 as level
        FROM sys_role WHERE role_id = p_role_id
        
        UNION ALL
        
        SELECT r.role_id, r.parent_role_id, rh.level + 1
        FROM sys_role r
        JOIN role_hierarchy rh ON r.role_id = rh.parent_role_id
        WHERE rh.level < 10  -- 防止无限递归
    )
    SELECT COUNT(*) > 0 INTO cycle_found
    FROM role_hierarchy
    WHERE level > 1 AND role_id = p_role_id;
    
    IF cycle_found THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Role inheritance cycle detected';
    END IF;
END;
```

### 2. 获取角色继承路径

```sql
-- 获取角色的完整继承路径
CREATE PROCEDURE GetRoleInheritancePath(IN p_role_id VARCHAR(32))
BEGIN
    WITH RECURSIVE inheritance_path AS (
        SELECT 
            role_id,
            role_code,
            role_name,
            parent_role_id,
            1 as level,
            CAST(role_code AS CHAR(1000)) as path
        FROM sys_role 
        WHERE role_id = p_role_id
        
        UNION ALL
        
        SELECT 
            r.role_id,
            r.role_code,
            r.role_name,
            r.parent_role_id,
            ip.level + 1,
            CONCAT(r.role_code, ' -> ', ip.path)
        FROM sys_role r
        JOIN inheritance_path ip ON r.role_id = ip.parent_role_id
        WHERE ip.level < 10
    )
    SELECT * FROM inheritance_path ORDER BY level DESC;
END;
```

### 3. 批量更新角色层级

```sql
-- 批量更新角色层级
CREATE PROCEDURE UpdateRoleLevels()
BEGIN
    WITH RECURSIVE role_levels AS (
        -- 根角色（没有父角色）
        SELECT 
            role_id,
            parent_role_id,
            0 as calculated_level
        FROM sys_role 
        WHERE parent_role_id IS NULL
        
        UNION ALL
        
        -- 子角色
        SELECT 
            r.role_id,
            r.parent_role_id,
            rl.calculated_level + 1
        FROM sys_role r
        JOIN role_levels rl ON r.parent_role_id = rl.role_id
    )
    UPDATE sys_role sr
    JOIN role_levels rl ON sr.role_id = rl.role_id
    SET sr.role_level = rl.calculated_level;
END;
```

---

## 🎯 前端角色管理界面

### Vue组件示例

```vue
<template>
  <div class="role-inheritance-manager">
    <el-tree
      :data="roleTree"
      :props="treeProps"
      node-key="role_id"
      :expand-on-click-node="false"
      :default-expand-all="true"
    >
      <template #default="{ node, data }">
        <div class="role-node">
          <span class="role-name">{{ data.role_name }}</span>
          <span class="role-level">Level {{ data.role_level }}</span>
          <el-button 
            size="small" 
            @click="addChildRole(data)"
            v-if="data.role_level < 5"
          >
            添加子角色
          </el-button>
        </div>
      </template>
    </el-tree>
  </div>
</template>

<script>
export default {
  data() {
    return {
      roleTree: [],
      treeProps: {
        children: 'children',
        label: 'role_name'
      }
    }
  },
  methods: {
    async loadRoleTree() {
      // 加载角色树数据
      const response = await this.$api.getRoleTree();
      this.roleTree = response.data;
    },
    
    async addChildRole(parentRole) {
      // 添加子角色
      const newRole = {
        parent_role_id: parentRole.role_id,
        role_level: parentRole.role_level + 1,
        inherit_permissions: true,
        inherit_data_scope: true
      };
      
      // 打开角色编辑对话框
      this.$refs.roleDialog.open(newRole);
    }
  }
}
</script>
```

---

## 📋 总结

### ✅ 角色继承的优势

1. **权限管理简化**: 上级角色自动拥有下级角色的权限
2. **组织架构清晰**: 符合实际的组织层级关系
3. **权限控制精确**: 支持权限和数据权限的分别继承
4. **扩展性强**: 支持多层级、多分支的角色继承

### 🎯 实施建议

1. **选择方案1**: 使用自关联角色表，简单高效
2. **权限继承**: 默认继承权限，可选择继承数据权限
3. **层级限制**: 建议限制最大层级，避免过度复杂
4. **循环检测**: 实现角色继承循环检测机制
5. **性能优化**: 缓存角色继承关系，减少递归查询

### 🔄 下一步工作

1. **更新表结构**: 在现有角色表中添加继承字段
2. **实现查询逻辑**: 开发角色继承相关的查询方法
3. **前端界面**: 开发角色继承管理界面
4. **测试验证**: 验证角色继承功能的正确性

这种角色继承设计能够很好地满足层级角色的业务需求，您觉得这个方案如何？
